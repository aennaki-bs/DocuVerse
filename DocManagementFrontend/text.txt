using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Utils;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AccountController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        public AccountController(ApplicationDbContext context) { _context = context; }

        [Authorize]
        [HttpGet("user-info")]
        public async Task<IActionResult> GetUserInfo()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userIdClaim))
                return Unauthorized("User ID claim is missing.");
            if (!int.TryParse(userIdClaim, out var userId))
                return BadRequest("Invalid user ID.");

            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return NotFound("User not found.");
            if (!user.IsActive)
                return Unauthorized("This account is desactivated!");
            var picture = string.Empty;
            if (!string.IsNullOrEmpty(user.ProfilePicture))
                {picture = $"{Request.Scheme}://{Request.Host}{user.ProfilePicture}";}
            var userInfo = new {userId = user.Id,
                username = user.Username, email = user.Email,
                role = user.Role?.RoleName ?? "SimpleUser",
                firstName = user.FirstName, lastName = user.LastName,
                profilePicture = picture, isActive = user.IsActive,
                address = user.Address, city = user.City, country = user.Country,
                phoneNumber = user.PhoneNumber, isOnline = user.IsOnline, //isBlocked = user.IsBlocked,
            };

            return Ok(userInfo);
        }

        [Authorize]
        [HttpGet("user-role")]
        public async Task<IActionResult> GetUserRole()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userIdClaim))
                return Unauthorized("User ID claim is missing.");
            if (!int.TryParse(userIdClaim, out var userId))
                return BadRequest("Invalid user ID.");
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return NotFound("User not found.");
            if (!user.IsActive)
                return Unauthorized("This account is desactivated!");
            var userRole = new { role = user.Role?.RoleName ?? "SimpleUser" };

            return Ok(userRole);
        }

        [HttpPost("forgot-password")]
        public async Task<IActionResult> ForgotPassword([FromBody] ForgotPasswordRequest request)
        {
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == request.Email);
            if (user == null)
                return NotFound("No user found with that email address.");
            if (!user.IsEmailConfirmed)
                return Unauthorized("Email Not Verified!");
            if (!user.IsActive)
                return Unauthorized("User Account Desactivated!");
            var verificationLink = $"{frontDomain}/update-password/{user.Email}";
            var emailBody = AuthHelper.createPassEmailBody(verificationLink);
            AuthHelper.SendEmail(user.Email, "Password Reset", emailBody);
            return Ok("A Link Is Sent To Your Email.");
        }

        [HttpPut("update-password")]
        public async Task<IActionResult> UpdatePassword([FromBody] ForgotPasswordRequest request)
        {
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == request.Email);
            if (user == null)
                return NotFound("No user found with that email address.");
            if (!user.IsEmailConfirmed)
                return Unauthorized("Email Not Verified!");
            if (!user.IsActive)
                return Unauthorized("User Account Desactivated!");
            if (!AuthHelper.IsValidPassword(request.NewPassword))
                return BadRequest("Password must be at least 8 characters long and include an uppercase letter, a lowercase letter, a digit, and a special character.");
            user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(request.NewPassword);
            await _context.SaveChangesAsync();
            return Ok("Your password is updated successfully!");
        }

        [HttpPost("resend-code")]
        public async Task<IActionResult> ResendCode([FromBody] ForgotPasswordRequest request) {
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            if (string.IsNullOrEmpty(request.Email))
                return BadRequest("Email is required!");
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == request.Email);
            if (user == null)
                return NotFound("No user found with that email address.");
            if (user.IsEmailConfirmed)
                return BadRequest("Email already verified!");
            var verifCode = new Random().Next(100000, 999999).ToString();
            // if (string.IsNullOrEmpty(user.EmailVerificationCode))
            user.EmailVerificationCode = verifCode;
            var verificationLink = $"{frontDomain}/verify/{user.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, user.EmailVerificationCode);
            AuthHelper.SendEmail(user.Email, "Email Verification", emailBody);
            await _context.SaveChangesAsync();
            return Ok("A Verification Code Is reSent To Your Email.");
        }

        [Authorize]
        [HttpPut("update-profile")]
        public async Task<IActionResult> UpdateProfile([FromBody] UpdateProfileRequest request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userIdClaim))
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.FindAsync(userId);
            if (user == null)
                return NotFound("User not found.");
            if (!string.IsNullOrEmpty(request.Username) && user.Username != request.Username)
            {
                var userName = await _context.Users.AnyAsync(u => u.Username == request.Username);
                if (userName)
                    return BadRequest("Username is already in use.");
            }
            user.Username = request.Username ?? user.Username;
            user.FirstName = request.FirstName ?? user.FirstName;
            user.Address = request.Address ?? user.Address;
            user.City = request.City ?? user.City;
            user.Country = request.Country ?? user.Country;
            user.PhoneNumber = request.PhoneNumber ?? user.PhoneNumber;
            user.LastName = request.LastName ?? user.LastName;
            if (!string.IsNullOrEmpty(request.NewPassword))
            {
                if (!string.IsNullOrEmpty(request.CurrentPassword))
                    {if (!BCrypt.Net.BCrypt.Verify(request.CurrentPassword, user.PasswordHash))
                        return BadRequest("Current password is incorrect.");}
                else { return BadRequest("Current password is required."); }
                if (!AuthHelper.IsValidPassword(request.NewPassword))
                    return BadRequest("New password does not meet complexity requirements.");
                user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(request.NewPassword);
            }
            await _context.SaveChangesAsync();
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = user,
                Timestamp = DateTime.UtcNow,
                ActionType = 3,
                Description = $"{user.Username} has updated their profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok("Profile updated successfully.");
        }

        [HttpPost("upload-image")]
        public async Task<IActionResult> UploadProfileImage(IFormFile file)
        {
            try {
                var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                if (string.IsNullOrEmpty(userIdClaim))
                    return Unauthorized("User ID claim is missing.");
                if (!int.TryParse(userIdClaim, out int userId))
                    return BadRequest("Invalid user ID format.");
                var user = await _context.Users.FindAsync(userId);
                if (user == null)
                    return NotFound("User not found.");
                if (file == null || file.Length == 0)
                    return BadRequest("No file uploaded.");
                var uploadPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", "images", "profile");
                if (!Directory.Exists(uploadPath))
                    Directory.CreateDirectory(uploadPath);
                var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif" };
                var fileExtension = Path.GetExtension(file.FileName).ToLower();
                if (!allowedExtensions.Contains(fileExtension))
                    return BadRequest("Invalid file type. Allowed: JPG, JPEG, PNG, GIF");
                if (file.Length > 5 * 1024 * 1024)
                    return BadRequest("File size exceeds 5MB limit");
                if (!string.IsNullOrEmpty(user.ProfilePicture) && user.ProfilePicture != "/images/profile/default.png") {
                    var oldPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", user.ProfilePicture.TrimStart('/'));
                    if (System.IO.File.Exists(oldPath))
                        System.IO.File.Delete(oldPath);}
                var sanitizedUsername = string.Join("", user.Username.Split(Path.GetInvalidFileNameChars()));
                var fileName = $"{sanitizedUsername}_{Guid.NewGuid()}{fileExtension}";
                var filePath = Path.Combine(uploadPath, fileName);
                using (var stream = new FileStream(filePath, FileMode.Create))
                    await file.CopyToAsync(stream);
                user.ProfilePicture = $"/images/profile/{fileName}";
                await _context.SaveChangesAsync();
                var baseUrl = $"{Request.Scheme}://{Request.Host}";
                return Ok(new {filePath = $"{baseUrl}{user.ProfilePicture}",
                    message = "Image uploaded successfully"});
            }
            catch (Exception ex) {return StatusCode(500, $"Internal server error: {ex.Message}");}
        }

        [HttpGet("profile-image/{userId}")]
        public async Task<IActionResult> GetProfileImage(int userId)
        {
            var user = await _context.Users.FindAsync(userId);
            if (user == null || string.IsNullOrEmpty(user.ProfilePicture))
                return NotFound("Profile image not found.");
            return Ok(new { ProfilePicture = user.ProfilePicture });
        }

        [Authorize]
        [HttpPut("update-email")]
        public async Task<IActionResult> UpdateEmail([FromBody] UpdateEmailRequest request) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userIdClaim))
                return Unauthorized("User ID claim is missing.");
            if (!int.TryParse(userIdClaim, out int userId))
                return BadRequest("Invalid user ID format.");
            var user = await _context.Users.FindAsync(userId);
            if (user == null)
                return NotFound("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is desactivated. Please contact an admin!");
            if (string.IsNullOrEmpty(request.Email))
                return BadRequest("Email is required!");
            if (await _context.Users.AnyAsync(u => u.Email == request.Email))
                return BadRequest("Email already in use!");
            user.Email = request.Email;
            user.EmailVerificationCode = new Random().Next(100000, 999999).ToString();
            user.IsActive = false;
            user.IsEmailConfirmed = false;
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var verificationLink = $"{frontDomain}/verify/{user.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, user.EmailVerificationCode);
            await _context.SaveChangesAsync();
            AuthHelper.SendEmail(user.Email, "Email Verification", emailBody);
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = user,
                Timestamp = DateTime.UtcNow,
                ActionType = 3,
                Description = $"{user.Username} has updated their profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok("Email is updated successfully. Please check your email for confirmation!");
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class ActionController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public ActionController(ApplicationDbContext context)
        {
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<ActionDto>>> GetActions()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var actions = await _context.Actions
                .OrderBy(a => a.Title)
                .Select(a => new ActionDto
                {
                    ActionId = a.Id,
                    ActionKey = a.ActionKey,
                    Title = a.Title,
                    Description = a.Description ?? string.Empty
                })
                .ToListAsync();

            return Ok(actions);
        }

        [HttpPost]
        public async Task<ActionResult<ActionDto>> CreateAction([FromBody] CreateActionDto createActionDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to create actions.");

            var action = new Models.Action
            {
                Title = createActionDto.Title,
                Description = createActionDto.Description,
                ActionKey = $"ACT-{Guid.NewGuid().ToString().Substring(0, 8)}"
            };

            _context.Actions.Add(action);
            await _context.SaveChangesAsync();

            return CreatedAtAction(nameof(GetAction), new { id = action.Id }, new ActionDto
            {
                ActionId = action.Id,
                ActionKey = action.ActionKey,
                Title = action.Title,
                Description = action.Description
            });
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateAction(int id, [FromBody] CreateActionDto updateActionDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact an admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to update actions.");

            var action = await _context.Actions.FindAsync(id);
            if (action == null)
                return NotFound("Action not found.");

            // Update the properties
            action.Title = updateActionDto.Title;
            action.Description = updateActionDto.Description;

            try
            {
                await _context.SaveChangesAsync();
                return Ok("Action updated successfully.");
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await _context.Actions.AnyAsync(a => a.Id == id))
                    return NotFound("Action no longer exists.");
                throw;
            }
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteAction(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact an admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to delete actions.");

            var action = await _context.Actions
                .Include(a => a.StepActions)
                .FirstOrDefaultAsync(a => a.Id == id);

            if (action == null)
                return NotFound("Action not found.");

            // Check if action is being used in any StepAction relationships
            if (action.StepActions.Any())
                return BadRequest("Cannot delete an action that is assigned to steps. Remove the action from all steps first.");

            // Check if action is referenced in any ActionStatusEffects
            var isReferenced = await _context.ActionStatusEffects.AnyAsync(ase => ase.ActionId == id);
            if (isReferenced)
            {
                // Delete the related ActionStatusEffects
                var relatedEffects = await _context.ActionStatusEffects.Where(ase => ase.ActionId == id).ToListAsync();
                _context.ActionStatusEffects.RemoveRange(relatedEffects);
            }

            // Check if action is referenced in DocumentCircuitHistory
            var isInHistory = await _context.DocumentCircuitHistory.AnyAsync(dch => dch.ActionId == id);
            if (isInHistory)
                return BadRequest("Cannot delete an action that has been used in document history.");

            // Remove the action
            _context.Actions.Remove(action);
            await _context.SaveChangesAsync();

            return Ok("Action deleted successfully.");
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<ActionDto>> GetAction(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var action = await _context.Actions.FindAsync(id);
            if (action == null)
                return NotFound("Action not found.");

            return Ok(new ActionDto
            {
                ActionId = action.Id,
                ActionKey = action.ActionKey,
                Title = action.Title,
                Description = action.Description ?? string.Empty // Provide default if null
            });
        }

        [HttpPost("assign-to-step")]
        public async Task<IActionResult> AssignActionToStep([FromBody] AssignActionToStepDto assignDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to assign actions to steps.");

            var step = await _context.Steps.FindAsync(assignDto.StepId);
            if (step == null)
                return NotFound("Step not found.");

            var action = await _context.Actions.FindAsync(assignDto.ActionId);
            if (action == null)
                return NotFound("Action not found.");

            // Check if already assigned
            var existing = await _context.StepActions
                .FirstOrDefaultAsync(sa => sa.StepId == assignDto.StepId && sa.ActionId == assignDto.ActionId);

            if (existing != null)
                return BadRequest("Action already assigned to this step.");

            var stepAction = new StepAction
            {
                StepId = assignDto.StepId,
                ActionId = assignDto.ActionId
            };

            _context.StepActions.Add(stepAction);
            await _context.SaveChangesAsync();

            // Now add status effects for this action if provided
            if (assignDto.StatusEffects != null && assignDto.StatusEffects.Any())
            {
                foreach (var effect in assignDto.StatusEffects)
                {
                    var status = await _context.Status.FindAsync(effect.StatusId);
                    if (status != null && status.StepId == assignDto.StepId)
                    {
                        var actionStatusEffect = new ActionStatusEffect
                        {
                            ActionId = assignDto.ActionId,
                            StepId = assignDto.StepId,
                            StatusId = effect.StatusId,
                            SetsComplete = effect.SetsComplete
                        };
                        _context.ActionStatusEffects.Add(actionStatusEffect);
                    }
                }
                await _context.SaveChangesAsync();
            }

            return Ok("Action assigned to step successfully.");
        }

        [HttpGet("by-step/{stepId}")]
        public async Task<ActionResult<IEnumerable<ActionDto>>> GetActionsByStep(int stepId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact an admin!");

            // First verify if the step exists
            var stepExists = await _context.Steps.AnyAsync(s => s.Id == stepId);
            if (!stepExists)
                return NotFound("Step not found.");

            // Get actions assigned to this step
            var actions = await _context.StepActions
                .Where(sa => sa.StepId == stepId)
                .Include(sa => sa.Action)
                .Select(sa => new ActionDto
                {
                    ActionId = sa.Action.Id,
                    ActionKey = sa.Action.ActionKey,
                    Title = sa.Action.Title,
                    Description = sa.Action.Description ?? string.Empty
                })
                .ToListAsync();

            return Ok(actions);
        }
    }
}using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using System.Security.Claims;
using DocManagementBackend.Mappings;
using DocManagementBackend.Utils;

namespace DocManagementBackend.Controllers
{
    [Authorize(Roles = "Admin")]
    [Route("api/[controller]")]
    [ApiController]
    public class AdminController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        public AdminController(ApplicationDbContext context) { _context = context; }

        [HttpGet("users")]
        public async Task<IActionResult> GetAllUsers()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var users = await _context.Users
                .Include(u => u.Role).Where(u => u.Id != userId).Select(UserMappings.ToUserDto).ToListAsync();
            return Ok(users);
        }

        [HttpGet("users/{id}")]
        public async Task<IActionResult> GetUser(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == id);
            if (user == null)
                return NotFound("User not found.");
            return Ok(user);
        }

        [HttpGet("roles")]
        public async Task<IActionResult> GetAllRoles()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact an admin!");
            if (thisUser.Role!.RoleName != "Admin")
                return Unauthorized("User not allowed to view roles.");

            var roles = await _context.Roles.ToListAsync();
            return Ok(roles);
        }

        [HttpPost("users")]
        public async Task<IActionResult> CreateUser([FromBody] AdminCreateUserRequest request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            if (await _context.Users.AnyAsync(u => u.Email == request.Email))
                return BadRequest("Email is already in use.");
            if (await _context.Users.AnyAsync(u => u.Username == request.Username))
                return BadRequest("Username is already in use.");
            int roleId = 0;
            if (request.RoleName == "Admin") { roleId = 1; }
            if (request.RoleName == "SimpleUser") { roleId = 2; }
            if (request.RoleName == "FullUser") { roleId = 3; }
            var role = await _context.Roles.FindAsync(roleId);
            if (role == null)
                return BadRequest("Invalid RoleName.");
            string hashedPassword = BCrypt.Net.BCrypt.HashPassword(request.PasswordHash);
            var emailVerificationCode = new Random().Next(100000, 999999).ToString();
            var newUser = new User
            {
                Email = request.Email,
                Username = request.Username,
                PasswordHash = hashedPassword,
                FirstName = request.FirstName,
                LastName = request.LastName,
                IsEmailConfirmed = false,
                IsActive = false,
                CreatedAt = DateTime.UtcNow,
                RoleId = roleId,
                EmailVerificationCode = emailVerificationCode,
                ProfilePicture = "/images/profile/default.png"
            };
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var verificationLink = $"{frontDomain}/verify/{newUser.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, newUser.EmailVerificationCode);
            _context.Users.Add(newUser);
            await _context.SaveChangesAsync();
            AuthHelper.SendEmail(newUser.Email, "Email Verification", emailBody);
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = ThisUser,
                Timestamp = DateTime.UtcNow,
                ActionType = 7,
                Description = $"{ThisUser.Username} has created a profile for {newUser.Username}"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return CreatedAtAction(nameof(GetUser), new { id = newUser.Id }, new
            {
                newUser.Id,
                newUser.Username,
                newUser.Email,
                newUser.FirstName,
                newUser.LastName,
                Role = role.RoleName,
                newUser.IsActive,
                newUser.CreatedAt
            });
        }

        [HttpPut("users/{id}")]
        public async Task<IActionResult> UpdateUser(int id, [FromBody] AdminUpdateUserRequest request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.FindAsync(id);
            if (user == null)
                return NotFound("User not found.");
            if (!string.IsNullOrEmpty(request.Username) && await _context.Users.AnyAsync(u => u.Username == request.Username) && user.Username != request.Username)
                return BadRequest("Username is already in use.");
            if (!string.IsNullOrEmpty(request.Username))
                user.Username = request.Username;
            if (!string.IsNullOrEmpty(request.PasswordHash))
            {
                if (!AuthHelper.IsValidPassword(request.PasswordHash))
                    return BadRequest("Password must be at least 8 characters long and include an uppercase letter, a lowercase letter, a digit, and a special character.");
                user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(request.PasswordHash);
            }
            if (!string.IsNullOrEmpty(request.FirstName))
                user.FirstName = request.FirstName;
            if (!string.IsNullOrEmpty(request.LastName))
                user.LastName = request.LastName;
            if (request.IsEmailConfirmed.HasValue)
                user.IsEmailConfirmed = request.IsEmailConfirmed.Value;
            if (request.IsActive.HasValue)
                user.IsActive = request.IsActive.Value;
            if (!string.IsNullOrEmpty(request.RoleName))
            {
                int roleId = 0;
                if (request.RoleName == "Admin") { roleId = 1; }
                if (request.RoleName == "SimpleUser") { roleId = 2; }
                if (request.RoleName == "FullUser") { roleId = 3; }
                var role = await _context.Roles.FindAsync(roleId);
                if (role == null)
                    return BadRequest("Invalid RoleName.");
                user.RoleId = role.Id; user.Role = role;
            }
            await _context.SaveChangesAsync();
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = ThisUser,
                Timestamp = DateTime.UtcNow,
                ActionType = 8,
                Description = $"{ThisUser.Username} has updated {user.Username}'s profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok("User updated successfully.");
        }

        [HttpPut("users/email/{id}")]
        public async Task<IActionResult> UpdateEmailUser(int id, [FromBody] AdminUpdateUserRequest request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.FindAsync(id);
            if (user == null)
                return NotFound("User not found.");
            if (!string.IsNullOrEmpty(request.Email) && await _context.Users.AnyAsync(u => u.Email == request.Email) && user.Email != request.Email)
                return BadRequest("Email is already in use.");
            if (!string.IsNullOrEmpty(request.Email))
                user.Email = request.Email;
            user.EmailVerificationCode = new Random().Next(100000, 999999).ToString();
            user.IsActive = false;
            user.IsEmailConfirmed = false;
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var verificationLink = $"{frontDomain}/verify/{user.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, user.EmailVerificationCode);
            await _context.SaveChangesAsync();
            AuthHelper.SendEmail(user.Email, "Email Verification", emailBody);
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = ThisUser,
                Timestamp = DateTime.UtcNow,
                ActionType = 8,
                Description = $"{ThisUser.Username} has updated {user.Username}'s profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok($"{user.Username}'s email is updated successfully. He need to check his email for confirmation!");
        }

        [HttpDelete("users/{id}")]
        public async Task<IActionResult> DeleteUser(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.FindAsync(id);
            if (user == null)
                return NotFound("User not found.");
            _context.Users.Remove(user);
            await _context.SaveChangesAsync();
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = ThisUser,
                Timestamp = DateTime.UtcNow,
                ActionType = 9,
                Description = $"{ThisUser.Username} has deleted {user.Username}'s profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok("User deleted successfully.");
        }

        [HttpDelete("delete-users")]
        public async Task<IActionResult> DeleteUsers([FromBody] List<int> userIds)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            if (userIds == null || !userIds.Any())
                return BadRequest("No user IDs provided.");
            var usersToDelete = await _context.Users.Where(u => userIds.Contains(u.Id)).ToListAsync();
            if (!usersToDelete.Any())
                return NotFound("No users found with the provided IDs.");
            int currentUserId = int.Parse(userIdClaim);
            usersToDelete.RemoveAll(u => u.Id == currentUserId);
            _context.Users.RemoveRange(usersToDelete);
            await _context.SaveChangesAsync();
            return Ok($"{usersToDelete.Count} Users Deleted Successfully.");
        }

        [HttpGet("logs/{id}")]
        public async Task<IActionResult> GetUserLogHistory(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == id);
            if (user == null)
                return NotFound("User not found!");
            var logsDto = await _context.LogHistories.Where(l => l.UserId == id).Include(l => l.User)
                .ThenInclude(u => u.Role)
            .Select(l => new LogHistoryDto
            {
                Id = l.Id,
                ActionType = l.ActionType,
                Timestamp = l.Timestamp,
                Description = l.Description,
                User = new UserLogDto
                {
                    Username = l.User.Username,
                    Role = l.User.Role != null ? l.User.Role.RoleName : string.Empty
                }
            }).OrderByDescending(l => l.Timestamp).ToListAsync();
            if (logsDto == null)
                return NotFound("User logs not found!");
            return Ok(logsDto);
        }
    }
}
// Console.ForegroundColor = ConsoleColor.Green;
// Console.WriteLine($"=== request Users === {request.RoleName}");
// Console.ResetColor();
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Utils;
using Microsoft.AspNetCore.Authorization;

namespace DocManagementBackend.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly IConfiguration _config;
        public AuthController(ApplicationDbContext context, IConfiguration config)
        {
            _context = context; _config = config;
        }

        [HttpPost("valide-email")]
        public async Task<IActionResult> ValideEmail([FromBody] ValideUsernameRequest request)
        {
            if (await _context.Users.AnyAsync(u => u.Email == request.Email))
                return Ok("False");
            return Ok("True");
        }

        [HttpPost("valide-username")]
        public async Task<IActionResult> ValideUsername([FromBody] ValideUsernameRequest request)
        {
            if (await _context.Users.AnyAsync(u => u.Username == request.Username))
                return Ok("False");
            return Ok("True");
        }

        [HttpPost("register")]
        public async Task<IActionResult> Register([FromBody] User user)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();
            var existingUser = await _context.Users.AnyAsync(u => u.Email == user.Email);
            if (existingUser)
                return BadRequest("Email is already in use.");
            var existingUsername = await _context.Users.AnyAsync(u => u.Username == user.Username);
            if (existingUsername)
                return BadRequest("Username is already in use.");
            if (!AuthHelper.IsValidPassword(user.PasswordHash))
                return BadRequest("Password must be at least 8 characters long and include an uppercase letter, a lowercase letter, a digit, and a special character.");
            var adminSecretHeader = Request.Headers["AdminSecret"].FirstOrDefault();
            if (!string.IsNullOrEmpty(adminSecretHeader))
            {
                var expectedAdminSecret = Environment.GetEnvironmentVariable("ADMIN_SECRET");
                if (adminSecretHeader == expectedAdminSecret)
                {
                    var adminRole = await _context.Roles.FirstOrDefaultAsync(r => r.RoleName == "Admin");
                    if (adminRole != null)
                        {user.RoleId = adminRole.Id; user.Role = adminRole;}
                }
                else
                    return Unauthorized("Invalid admin secret.");
            }
            else
            {
                var simpleUserRole = await _context.Roles.FirstOrDefaultAsync(r => r.RoleName == "SimpleUser");
                if (simpleUserRole != null)
                    {user.RoleId = simpleUserRole.Id; user.Role = simpleUserRole;}
                else
                    return BadRequest("Default role not found.");
            }
            user.EmailVerificationCode = new Random().Next(100000, 999999).ToString();
            user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(user.PasswordHash);
            user.IsActive = false;
            user.IsEmailConfirmed = false;
            user.ProfilePicture = "/images/profile/default.png";
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var verificationLink = $"{frontDomain}/verify/{user.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, user.EmailVerificationCode);
            try
            {
                _context.Users.Add(user);
                var logEntry = new LogHistory
                {
                    UserId = user.Id,
                    User = user,
                    Timestamp = DateTime.UtcNow,
                    ActionType = 2,
                    Description = $"{user.Username} has created their profile"
                };
                _context.LogHistories.Add(logEntry);
                await _context.SaveChangesAsync();
                await transaction.CommitAsync();
                AuthHelper.SendEmail(user.Email, "Email Verification", emailBody);
                return Ok("Registration successful! Please check your email for the verification code.");
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
                return StatusCode(500, $"An error occurred. Please try again. {ex.Message}");
            }
        }

        [HttpPost("verify-email")]
        public async Task<IActionResult> VerifyEmail([FromBody] VerifyEmailRequest request)
        {
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == request.Email);
            if (user == null)
                return NotFound("User not found.");
            if (user.IsEmailConfirmed && user.EmailVerificationCode == null)
                return BadRequest("Email is already verified !");
            if (user.EmailVerificationCode != request.VerificationCode)
                return BadRequest("Invalid verification code.");
            user.IsEmailConfirmed = true;
            user.IsActive = true;
            // user.IsOnline = false;
            user.EmailVerificationCode = null;
            await _context.SaveChangesAsync();

            return Ok("Email verified successfully!");
        }

        [HttpPost("clear-users")]
        public async Task<IActionResult> ClearUsers()
        {
            var users = _context.Users.Where(u => u.Email != null).ToList();
            _context.Users.RemoveRange(users);
            await _context.SaveChangesAsync();
            return Ok("All users with emails have been deleted.");
        }

        [HttpPost("clear-users/{id}")]
        public async Task<IActionResult> ClearUser(int id)
        {
            var user = _context.Users.Where(u => u.Id == id).ToList();
            _context.Users.RemoveRange(user);
            await _context.SaveChangesAsync();
            return Ok("the user have been deleted.");
        }

        [HttpPost("login")]
        public async Task<IActionResult> Login([FromBody] LoginRequest model)
        {
            if (string.IsNullOrEmpty(model.EmailOrUsername))
                return BadRequest("Email or Username is required.");
            if (string.IsNullOrEmpty(model.Password))
                return BadRequest("Password is required.");
            var user = await _context.Users
                .Include(u => u.Role)
                .FirstOrDefaultAsync(u => u.Email == model.EmailOrUsername || u.Username == model.EmailOrUsername);
            if (user == null) {return Unauthorized("Invalid email or username.");}
            if (!BCrypt.Net.BCrypt.Verify(model.Password, user.PasswordHash))
                return Unauthorized("Invalid password.");
            if (!user.IsEmailConfirmed)
                return Unauthorized("Your account is not activated yet. Please check your email for verification before logging in.");
            if (!user.IsActive)
                return Unauthorized("User Account Is Desactivated. Please contact an admin!");
            var accessToken = AuthHelper.GenerateAccessToken(user);
            var refreshToken = AuthHelper.GenerateRefreshToken();
            user.RefreshToken = refreshToken;
            user.RefreshTokenExpiry = DateTime.UtcNow.AddDays(7);
            user.IsOnline = true;
            var login = new LogHistory { UserId = user.Id, User = user, ActionType = 1, Description = "login", Timestamp = DateTime.UtcNow };
            _context.LogHistories.Add(login);
            await _context.SaveChangesAsync();
            var cookieOptions = new CookieOptions
            {
                HttpOnly = true,
                Secure = true,
                SameSite = SameSiteMode.None,
                Expires = DateTime.UtcNow.AddHours(3)
            };
            Response.Cookies.Append("accessToken", accessToken, cookieOptions);
            Response.Cookies.Append("refreshToken", refreshToken, cookieOptions);
            return Ok(new { accessToken, refreshToken });
        }

        [HttpPost("refresh-token")]
        public async Task<IActionResult> RefreshToken()
        {
            var refreshToken = Request.Cookies["refresh_token"];
            if (string.IsNullOrEmpty(refreshToken))
                return Unauthorized("No refresh token provided.");
            var user = await _context.Users.FirstOrDefaultAsync(u => u.RefreshToken == refreshToken);
            if (user == null || user.RefreshTokenExpiry < DateTime.UtcNow)
                return Unauthorized("Invalid or expired refresh token.");
            var newAccessToken = AuthHelper.GenerateAccessToken(user);
            var newRefreshToken = AuthHelper.GenerateRefreshToken();
            user.RefreshToken = newRefreshToken;
            user.RefreshTokenExpiry = DateTime.UtcNow.AddHours(3);
            await _context.SaveChangesAsync();
            var cookieOptions = new CookieOptions
            {
                HttpOnly = true,
                Secure = true,
                SameSite = SameSiteMode.None,
                Expires = DateTime.UtcNow.AddDays(7)
            };
            // Response.Cookies.Append("accessToken", accessToken, cookieOptions);
            Response.Cookies.Append("refreshToken", refreshToken, cookieOptions);

            return Ok(new { accessToken = newAccessToken });
        }

        [Authorize]
        [HttpPost("logout")]
        public async Task<IActionResult> Logout([FromBody] LogoutRequest request)
        {
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Id == request.UserId);
            if (user == null)
                return Unauthorized("User Not Found!");
            var logEntry = new LogHistory { UserId = user.Id, User = user, Timestamp = DateTime.UtcNow, ActionType = 0, Description = "logout"};
            _context.LogHistories.Add(logEntry);
            user.RefreshToken = null;
            user.RefreshTokenExpiry = null;
            user.IsOnline = false;
            await _context.SaveChangesAsync();
            Response.Cookies.Delete("refresh_token");

            return Ok("Logged out successfully.");
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Services;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class CircuitController : ControllerBase
    {
        private readonly CircuitManagementService _circuitService;
        private readonly ApplicationDbContext _context;

        public CircuitController(CircuitManagementService circuitService, ApplicationDbContext context)
        {
            _circuitService = circuitService;
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<CircuitDto>>> GetCircuits()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var circuits = await _context.Circuits
                .Include(c => c.Steps.OrderBy(cd => cd.OrderIndex))
                .ToListAsync();

            var circuitDtos = circuits.Select(c => new CircuitDto
            {
                Id = c.Id,
                CircuitKey = c.CircuitKey,
                Title = c.Title,
                Descriptif = c.Descriptif,
                IsActive = c.IsActive,
                HasOrderedFlow = c.HasOrderedFlow,
                AllowBacktrack = c.AllowBacktrack,
                Steps = c.Steps.Select(cd => new StepDto
                {
                    Id = cd.Id,
                    StepKey = cd.StepKey,
                    CircuitId = cd.CircuitId,
                    Title = cd.Title,
                    Descriptif = cd.Descriptif,
                    OrderIndex = cd.OrderIndex,
                    ResponsibleRoleId = cd.ResponsibleRoleId,
                    IsFinalStep = cd.IsFinalStep
                }).ToList()
            }).ToList();

            return Ok(circuitDtos);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<CircuitDto>> GetCircuit(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var circuit = await _context.Circuits
                .Include(c => c.Steps.OrderBy(cd => cd.OrderIndex))
                .FirstOrDefaultAsync(c => c.Id == id);

            if (circuit == null)
                return NotFound("Circuit not found.");

            var circuitDto = new CircuitDto
            {
                Id = circuit.Id,
                CircuitKey = circuit.CircuitKey,
                Title = circuit.Title,
                Descriptif = circuit.Descriptif,
                IsActive = circuit.IsActive,
                HasOrderedFlow = circuit.HasOrderedFlow,
                AllowBacktrack = circuit.AllowBacktrack,
                Steps = circuit.Steps.Select(cd => new StepDto
                {
                    Id = cd.Id,
                    StepKey = cd.StepKey,
                    CircuitId = cd.CircuitId,
                    Title = cd.Title,
                    Descriptif = cd.Descriptif,
                    OrderIndex = cd.OrderIndex,
                    ResponsibleRoleId = cd.ResponsibleRoleId,
                    IsFinalStep = cd.IsFinalStep
                }).ToList()
            };

            return Ok(circuitDto);
        }

        [HttpGet("{circuitId}/validation")]
        public async Task<ActionResult<CircuitValidationDto>> ValidateCircuitStructure(int circuitId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact an admin!");

            // Get the circuit with its steps
            var circuit = await _context.Circuits
                .Include(c => c.Steps)
                .FirstOrDefaultAsync(c => c.Id == circuitId);

            if (circuit == null)
                return NotFound("Circuit not found.");

            // Prepare validation response
            var validation = new CircuitValidationDto
            {
                CircuitId = circuit.Id,
                CircuitTitle = circuit.Title,
                HasSteps = circuit.Steps.Any(),
                TotalSteps = circuit.Steps.Count,
                StepsWithoutStatuses = new List<StepValidationDto>()
            };

            if (validation.HasSteps)
            {
                // For each step, check if it has statuses
                foreach (var step in circuit.Steps)
                {
                    var statusCount = await _context.Status.CountAsync(s => s.StepId == step.Id);

                    if (statusCount == 0)
                    {
                        validation.StepsWithoutStatuses.Add(new StepValidationDto
                        {
                            StepId = step.Id,
                            StepTitle = step.Title,
                            Order = step.OrderIndex
                        });
                    }
                }

                validation.AllStepsHaveStatuses = validation.StepsWithoutStatuses.Count == 0;
                validation.IsValid = validation.HasSteps && validation.AllStepsHaveStatuses;
            }
            else
            {
                validation.AllStepsHaveStatuses = false;
                validation.IsValid = false;
            }

            return Ok(validation);
        }

        [HttpPost]
        public async Task<ActionResult<CircuitDto>> CreateCircuit([FromBody] CreateCircuitDto createCircuitDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to create circuits.");

            Console.WriteLine($"is active value ========> {createCircuitDto.IsActive}");

            var circuit = new Circuit
            {
                Title = createCircuitDto.Title,
                Descriptif = createCircuitDto.Descriptif,
                HasOrderedFlow = createCircuitDto.HasOrderedFlow,
                AllowBacktrack = createCircuitDto.AllowBacktrack,
                IsActive = createCircuitDto.IsActive
            };

            try
            {
                Console.WriteLine($"is active value circuit ========> {circuit.IsActive}");
                var createdCircuit = await _circuitService.CreateCircuitAsync(circuit);
                Console.WriteLine($"is active value circuit ========> {createdCircuit.IsActive}");

                return CreatedAtAction(nameof(GetCircuit), new { id = createdCircuit.Id }, new CircuitDto
                {
                    Id = createdCircuit.Id,
                    CircuitKey = createdCircuit.CircuitKey,
                    Title = createdCircuit.Title,
                    Descriptif = createdCircuit.Descriptif,
                    IsActive = createdCircuit.IsActive,
                    HasOrderedFlow = createdCircuit.HasOrderedFlow,
                    AllowBacktrack = createdCircuit.AllowBacktrack,
                    Steps = new List<StepDto>()
                });
            }
            catch (Exception ex)
            {
                return BadRequest($"Error creating circuit: {ex.Message}");
            }
        }

        [HttpPut("steps/{stepId}")]
        public async Task<IActionResult> UpdateStep(int stepId, [FromBody] UpdateStepDto updateStepDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to modify steps.");

            // Find the step to update
            var step = await _context.Steps.Include(s => s.Circuit).FirstOrDefaultAsync(s => s.Id == stepId);
            if (step == null)
                return NotFound("Step not found.");

            // Check if the step belongs to an active circuit
            if (step.Circuit != null && step.Circuit.IsActive)
                return BadRequest("Cannot update a step that belongs to an active circuit.");

            // Update step properties
            if (!string.IsNullOrEmpty(updateStepDto.Title))
                step.Title = updateStepDto.Title;

            if (!string.IsNullOrEmpty(updateStepDto.Descriptif))
                step.Descriptif = updateStepDto.Descriptif;

            // if (updateStepDto.OrderIndex > 0)
            //     step.OrderIndex = updateStepDto.OrderIndex;

            // if (updateStepDto.ResponsibleRoleId.HasValue)
            // {
            //     // Validate role ID if provided
            //     var role = await _context.Roles.FindAsync(updateStepDto.ResponsibleRoleId.Value);
            //     if (role == null)
            //         return BadRequest("Invalid role ID.");

            //     step.ResponsibleRoleId = updateStepDto.ResponsibleRoleId;
            // }

            if (updateStepDto.IsFinalStep.HasValue)
                step.IsFinalStep = updateStepDto.IsFinalStep.Value;

            try
            {
                await _context.SaveChangesAsync();
                return Ok("Step updated successfully.");
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await _context.Steps.AnyAsync(s => s.Id == stepId))
                    return NotFound("Step no longer exists.");
                throw;
            }
        }

        [HttpPost("{circuitId}/steps")]
        public async Task<ActionResult<StepDto>> AddStepToCircuit(int circuitId, [FromBody] CreateStepDto createStepDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to modify circuits.");

            var step = new Step
            {
                CircuitId = circuitId,
                Title = createStepDto.Title,
                Descriptif = createStepDto.Descriptif,
                ResponsibleRoleId = createStepDto.ResponsibleRoleId,
                OrderIndex = 0
            };

            try
            {
                var createdStep = await _circuitService.AddStepToCircuitAsync(step);

                return CreatedAtAction(nameof(GetCircuit), new { id = circuitId }, new StepDto
                {
                    Id = createdStep.Id,
                    StepKey = createdStep.StepKey,
                    CircuitId = createdStep.CircuitId,
                    Title = createdStep.Title,
                    Descriptif = createdStep.Descriptif,
                    OrderIndex = createdStep.OrderIndex,
                    ResponsibleRoleId = createdStep.ResponsibleRoleId,
                    IsFinalStep = createdStep.IsFinalStep
                });
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (Exception ex)
            {
                return BadRequest($"Error adding step: {ex.Message}");
            }
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateCircuit(int id, [FromBody] CreateCircuitDto updateCircuitDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to modify circuits.");

            var circuit = await _context.Circuits.FindAsync(id);
            if (circuit == null)
                return NotFound("Circuit not found.");

            circuit.Title = updateCircuitDto.Title;
            circuit.Descriptif = updateCircuitDto.Descriptif;
            circuit.HasOrderedFlow = updateCircuitDto.HasOrderedFlow;
            circuit.AllowBacktrack = updateCircuitDto.AllowBacktrack;
            circuit.IsActive = updateCircuitDto.IsActive;

            try
            {
                await _context.SaveChangesAsync();
                return Ok("Circuit updated successfully.");
            }
            catch (Exception ex)
            {
                return BadRequest($"Error updating circuit: {ex.Message}");
            }
        }

        [HttpDelete("steps/{stepId}")]
        public async Task<IActionResult> DeleteStep(int stepId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to delete steps.");

            // Find the step to delete
            var step = await _context.Steps
                .Include(s => s.Circuit)
                .Include(s => s.Statuses)
                .Include(s => s.StepActions)
                .FirstOrDefaultAsync(s => s.Id == stepId);

            if (step == null)
                return NotFound("Step not found.");

            // Check if the step belongs to an active circuit
            if (step.Circuit != null && step.Circuit.IsActive)
                return BadRequest("Cannot delete a step that belongs to an active circuit.");

            // Check if the step is referenced by any document
            var isReferenced = await _context.Documents.AnyAsync(d => d.CurrentStepId == stepId);
            if (isReferenced)
                return BadRequest("Cannot delete a step that is currently in use by documents.");

            // Check if the step has previous/next references from other steps
            var hasReferences = await _context.Steps.AnyAsync(s => s.NextStepId == stepId || s.PrevStepId == stepId);
            if (hasReferences)
            {
                // Remove references from other steps
                var referencingSteps = await _context.Steps
                    .Where(s => s.NextStepId == stepId || s.PrevStepId == stepId)
                    .ToListAsync();

                foreach (var refStep in referencingSteps)
                {
                    if (refStep.NextStepId == stepId)
                        refStep.NextStepId = null;
                    if (refStep.PrevStepId == stepId)
                        refStep.PrevStepId = null;
                }
            }

            // Delete related entities first
            if (step.Statuses.Any())
            {
                // Check if statuses are used in DocumentStatus
                var statusIds = step.Statuses.Select(s => s.Id).ToList();
                var statusesInUse = await _context.DocumentStatus.AnyAsync(ds => statusIds.Contains(ds.StatusId));

                if (statusesInUse)
                    return BadRequest("Cannot delete step with statuses that are in use by documents.");

                _context.Status.RemoveRange(step.Statuses);
            }

            if (step.StepActions.Any())
            {
                _context.StepActions.RemoveRange(step.StepActions);
            }

            // Delete any ActionStatusEffects related to this step
            var actionEffects = await _context.ActionStatusEffects.Where(ase => ase.StepId == stepId).ToListAsync();
            if (actionEffects.Any())
            {
                _context.ActionStatusEffects.RemoveRange(actionEffects);
            }

            // Delete the step
            _context.Steps.Remove(step);

            // Update OrderIndex values for remaining steps in the circuit
            if (step.CircuitId > 0)
            {
                var remainingSteps = await _context.Steps
                    .Where(s => s.CircuitId == step.CircuitId && s.Id != stepId)
                    .OrderBy(s => s.OrderIndex)
                    .ToListAsync();

                for (int i = 0; i < remainingSteps.Count; i++)
                {
                    remainingSteps[i].OrderIndex = i + 1;
                }
            }

            try
            {
                await _context.SaveChangesAsync();
                return Ok("Step deleted successfully.");
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"Error deleting step: {ex.Message}");
            }
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteCircuit(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to delete circuits.");

            var circuit = await _context.Circuits.FindAsync(id);
            if (circuit == null)
                return NotFound("Circuit not found.");

            // Check if circuit is in use by documents
            var inUse = await _context.Documents.AnyAsync(d => d.CircuitId == id);
            if (inUse)
                return BadRequest("Cannot delete circuit that is in use by documents.");

            _context.Circuits.Remove(circuit);
            await _context.SaveChangesAsync();

            return Ok("Circuit deleted successfully.");
        }
    }
}using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using Microsoft.AspNetCore.Authorization;
using System.Linq;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class DashboardController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public DashboardController(ApplicationDbContext context)
        {
            _context = context;
        }

        [HttpGet("stats")]
        public async Task<IActionResult> GetDashboardStats()
        {
            try
            {
                // Get total documents count
                var totalDocuments = await _context.Documents.CountAsync();

                // Get active circuits count (circuits with status = active)
                var activeCircuits = await _context.Circuits
                    .Where(c => c.IsActive)
                    .CountAsync();

                // Get pending approvals count (documents with status = pending)
                var pendingApprovals = await _context.Documents
                    .Where(d => d.Status == 2) // Assuming 2 is pending status
                    .CountAsync();

                // Get team members count (active users)
                var teamMembers = await _context.Users
                    .Where(u => u.IsActive)
                    .CountAsync();

                // Calculate completion rate (approved documents / total documents)
                var approvedDocuments = await _context.Documents
                    .Where(d => d.Status == 1) // Assuming 1 is approved status
                    .CountAsync();
                var completionRate = totalDocuments > 0 
                    ? (approvedDocuments * 100.0 / totalDocuments)
                    : 0;

                // Get document activity (documents created per month)
                var now = DateTime.UtcNow;
                var startDate = now.AddMonths(-11);
                
                // Fetch all documents within the date range
                var documents = await _context.Documents
                    .Where(d => d.CreatedAt >= startDate)
                    .Select(d => new { d.CreatedAt })
                    .ToListAsync();

                // Group documents in memory
                var documentActivity = documents
                    .GroupBy(d => new { Year = d.CreatedAt.Year, Month = d.CreatedAt.Month })
                    .Select(g => new
                    {
                        Month = $"{g.Key.Year}-{g.Key.Month:D2}",
                        Value = g.Count()
                    })
                    .OrderBy(x => x.Month)
                    .ToList();

                // Get weekly stats (documents created in the last 12 weeks)
                var weekStart = now.AddDays(-83); // 12 weeks * 7 days - 1 day
                var recentDocuments = await _context.Documents
                    .Where(d => d.CreatedAt >= weekStart)
                    .Select(d => new { d.CreatedAt })
                    .ToListAsync();

                // Calculate weekly stats in memory
                var weeklyStats = recentDocuments
                    .GroupBy(d => ((int)(now - d.CreatedAt).TotalDays / 7) + 1)
                    .Select(g => new
                    {
                        Name = g.Key.ToString(),
                        Value = g.Count()
                    })
                    .OrderBy(x => x.Name)
                    .ToList();

                // Calculate activity score
                var activeUsers = await _context.Users
                    .Where(u => u.IsActive && u.IsOnline)
                    .CountAsync();

                // Activity score is based on:
                // - Ratio of active users (30%)
                // - Document completion rate (40%)
                // - Circuit activity (30%)
                var totalUsers = await _context.Users.CountAsync();
                var activeUserRatio = totalUsers > 0 ? (activeUsers * 100.0 / totalUsers) : 0;
                
                // Calculate circuit activity based on active circuits ratio
                var totalCircuits = await _context.Circuits.CountAsync();
                var circuitActivityRatio = totalCircuits > 0 
                    ? (activeCircuits * 100.0 / totalCircuits) 
                    : 0;

                var activityScore = (
                    (activeUserRatio * 0.3) +
                    (completionRate * 0.4) +
                    (circuitActivityRatio * 0.3)
                ) / 10; // Scale to 0-10

                return Ok(new
                {
                    TotalDocuments = totalDocuments,
                    ActiveCircuits = activeCircuits,
                    PendingApprovals = pendingApprovals,
                    TeamMembers = teamMembers,
                    DocumentActivity = documentActivity,
                    WeeklyStats = weeklyStats,
                    CompletionRate = Math.Round(completionRate, 1),
                    ActivityScore = new
                    {
                        ActiveUsers = activeUsers,
                        Score = Math.Round(activityScore, 1)
                    }
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"Internal server error: {ex.Message}");
            }
        }
    }
} using Microsoft.AspNetCore.Mvc;
using DocManagementBackend.Models;
using DocManagementBackend.Data;
using Microsoft.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;
using System.Security.Claims;
using DocManagementBackend.Mappings;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class DocumentsController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        public DocumentsController(ApplicationDbContext context) { _context = context; }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<DocumentDto>>> GetDocuments()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var documents = await _context.Documents
                .Include(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Include(d => d.DocumentType)
                .Include(d => d.SubType)
                .Include(d => d.CurrentStep)
                .Include(d => d.Lignes)
                .Select(DocumentMappings.ToDocumentDto)
                .ToListAsync();

            return Ok(documents);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<DocumentDto>> GetDocument(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var documentDto = await _context.Documents
                .Include(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Include(d => d.DocumentType)
                .Include(d => d.SubType)
                .Include(d => d.CurrentStep)
                .Include(d => d.Lignes)
                .Where(d => d.Id == id)
                .Select(DocumentMappings.ToDocumentDto)
                .FirstOrDefaultAsync();
            if (documentDto == null) { return NotFound("Document not found!"); }

            return Ok(documentDto);
        }

        [HttpGet("recent")]
        public async Task<ActionResult<IEnumerable<DocumentDto>>> GetRecentDocuments([FromQuery] int limit = 5)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            // Ensure the limit is reasonable
            if (limit <= 0)
                limit = 5;
            if (limit > 50)
                limit = 50; // Set a maximum limit to prevent excessive queries

            var recentDocuments = await _context.Documents
                .Include(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Include(d => d.DocumentType)
                .Include(d => d.SubType)
                .Include(d => d.CurrentStep)
                .Include(d => d.Lignes)
                .OrderByDescending(d => d.CreatedAt) // Sort by creation date, newest first
                .Take(limit) // Take only the specified number of documents
                .Select(DocumentMappings.ToDocumentDto)
                .ToListAsync();

            return Ok(recentDocuments);
        }

        [HttpPost]
        public async Task<ActionResult<DocumentDto>> CreateDocument([FromBody] CreateDocumentRequest request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");

            var docType = await _context.DocumentTypes.FirstOrDefaultAsync(t => t.Id == request.TypeId);
            if (docType == null)
                return BadRequest("Invalid Document type!");

            SubType? subType = null;
            if (request.SubTypeId.HasValue)
            {
                subType = await _context.SubTypes.FirstOrDefaultAsync(s => s.Id == request.SubTypeId.Value);
                if (subType == null)
                    return BadRequest("Invalid SubType!");

                if (subType.DocumentTypeId != request.TypeId)
                    return BadRequest("Selected SubType does not belong to the selected Document Type!");

                var documentDate = request.DocDate ?? DateTime.UtcNow;
                if (documentDate < subType.StartDate || documentDate > subType.EndDate)
                    return BadRequest($"Document date ({documentDate:d}) must be within the selected SubType date range ({subType.StartDate:d} to {subType.EndDate:d})");
            }

            var docDate = request.DocDate ?? DateTime.UtcNow;
            var docAlias = "D";
            if (!string.IsNullOrEmpty(request.DocumentAlias))
                docAlias = request.DocumentAlias.ToUpper();

            docType.DocumentCounter++;
            docType.DocCounter++;
            int counterValue = docType.DocCounter;
            string paddedCounter = counterValue.ToString("D4");

            string documentKey;
            if (subType != null)
                documentKey = $"{subType.SubTypeKey}-{paddedCounter}";
            else
                documentKey = $"{docType.TypeKey}{docAlias}-{paddedCounter}";

            var document = new Document
            {
                Title = request.Title,
                DocumentAlias = docAlias,
                Content = request.Content,
                CreatedByUserId = userId,
                CreatedBy = user,
                DocDate = docDate,
                TypeId = request.TypeId,
                DocumentType = docType,
                SubTypeId = request.SubTypeId,
                SubType = subType,
                CircuitId = request.CircuitId,
                Status = 0,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                DocumentKey = documentKey
            };

            _context.Documents.Add(document);
            await _context.SaveChangesAsync();

            // Now fetch the complete document with all related entities
            var createdDocument = await _context.Documents
                .Include(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Include(d => d.DocumentType)
                .Include(d => d.SubType)
                .Include(d => d.CurrentStep)
                .Where(d => d.Id == document.Id)
                .Select(DocumentMappings.ToDocumentDto)
                .FirstOrDefaultAsync();

            var logEntry = new LogHistory
            {
                UserId = userId,
                User = user,
                Timestamp = DateTime.UtcNow,
                ActionType = 4,
                Description = $"{user.Username} has created the document {document.DocumentKey}"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();

            return CreatedAtAction(nameof(GetDocument), new { id = document.Id }, createdDocument);
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateDocument(int id, [FromBody] UpdateDocumentRequest request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");
            var document = await _context.Documents.FindAsync(id);
            if (document == null)
                return NotFound("Document not found.");

            // Update basic document fields
            document.Content = request.Content ?? document.Content;
            document.Title = request.Title ?? document.Title;
            document.DocDate = request.DocDate ?? document.DocDate;

            // Handle SubType changes
            if (request.SubTypeId.HasValue && request.SubTypeId != document.SubTypeId)
            {
                var subType = await _context.SubTypes.FindAsync(request.SubTypeId.Value);
                if (subType == null)
                    return BadRequest("Invalid SubType!");

                // If type is also changing, verify SubType belongs to that type
                if (request.TypeId.HasValue && request.TypeId != document.TypeId)
                {
                    if (subType.DocumentTypeId != request.TypeId.Value)
                        return BadRequest("Selected SubType does not belong to the selected Document Type!");
                }
                else
                {
                    // Otherwise check against current document type
                    if (subType.DocumentTypeId != document.TypeId)
                        return BadRequest("Selected SubType does not belong to the document's current type!");
                }

                // Verify DocDate falls within SubType date range
                if (document.DocDate < subType.StartDate || document.DocDate > subType.EndDate)
                    return BadRequest($"Document date ({document.DocDate:d}) must be within the selected SubType date range ({subType.StartDate:d} to {subType.EndDate:d})");

                document.SubTypeId = request.SubTypeId;
                document.SubType = subType;

                // Need to update document key
                var docType = await _context.DocumentTypes.FindAsync(document.TypeId);

                // Extract counter from the existing key (assuming format ends with -XXXX)
                string counterStr = document.DocumentKey.Split('-').Last();
                string documentKey = $"{subType.SubTypeKey}-{counterStr}";
                document.DocumentKey = documentKey;
            }
            // Handle removing a subtype
            else if (request.SubTypeId.HasValue && request.SubTypeId.Value == 0 && document.SubTypeId.HasValue)
            {
                document.SubTypeId = null;
                document.SubType = null;

                // Regenerate document key using the document type
                var docType = await _context.DocumentTypes.FindAsync(document.TypeId);
                string counterStr = document.DocumentKey.Split('-').Last();
                string documentKey = $"{docType!.TypeKey}{document.DocumentAlias}-{counterStr}";
                document.DocumentKey = documentKey;
            }

            // Handle type changes as in original method
            if (request.TypeId.HasValue)
            {
                // Console.ForegroundColor = ConsoleColor.Green;
                // Console.WriteLine($"=== request TYpe === {request.TypeId}");
                // Console.ResetColor();
                if (request.TypeId != document.TypeId)
                {
                    var docType = await _context.DocumentTypes.FirstOrDefaultAsync(t => t.Id == request.TypeId);
                    if (docType == null)
                        return BadRequest("Invalid type!");
                    var type = await _context.DocumentTypes.FirstOrDefaultAsync(t => t.Id == document.TypeId);
                    if (type == null)
                        return BadRequest("Missing DocumentType");
                    type.DocumentCounter--;

                    // If changing document type, clear the subtype if it doesn't match
                    if (document.SubTypeId.HasValue)
                    {
                        var subType = await _context.SubTypes.FindAsync(document.SubTypeId.Value);
                        if (subType!.DocumentTypeId != request.TypeId)
                        {
                            document.SubTypeId = null;
                            document.SubType = null;
                        }
                    }

                    document.TypeId = request.TypeId ?? document.TypeId;
                    document.DocumentType = docType;
                    docType.DocumentCounter++;
                    int counterValue = docType.DocumentCounter;
                    string paddedCounter = counterValue.ToString("D4");

                    if (document.SubTypeId.HasValue && document.SubType != null)
                        document.DocumentKey = $"{document.SubType.SubTypeKey}-{paddedCounter}";
                    else
                        document.DocumentKey = $"{docType.TypeKey}{document.DocumentAlias.ToUpper()}-{paddedCounter}";
                }
            }

            if (!string.IsNullOrEmpty(request.DocumentAlias))
            {
                document.DocumentAlias = request.DocumentAlias.ToUpper();

                // Only update the document key if we're not using a subtype
                if (!document.SubTypeId.HasValue)
                {
                    var docType = await _context.DocumentTypes.FindAsync(document.TypeId);
                    string counterStr = document.DocumentKey.Split('-').Last();
                    document.DocumentKey = $"{docType!.TypeKey}{request.DocumentAlias.ToUpper()}-{counterStr}";
                }
            }

            if (request.CircuitId.HasValue)
            {
                var circuit = await _context.Circuits.FirstOrDefaultAsync(c => c.Id == request.CircuitId);
                if (circuit == null)
                    return BadRequest("Invalid Circuit!");
                document.CircuitId = request.CircuitId;
                document.Circuit = circuit;
            }

            document.UpdatedAt = DateTime.UtcNow;
            _context.Entry(document).State = EntityState.Modified;

            try
            {
                await _context.SaveChangesAsync();
                var logEntry = new LogHistory
                {
                    UserId = userId,
                    User = user,
                    Timestamp = DateTime.UtcNow,
                    ActionType = 5,
                    Description = $"{user.Username} has updated the document {document.DocumentKey}"
                };
                _context.LogHistories.Add(logEntry);
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!_context.Documents.Any(d => d.Id == id)) { return NotFound(); }
                else { throw; }
            }
            return Ok("Document updated!");
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteDocument(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");

            // Begin a transaction to ensure all operations either succeed or fail together
            using var transaction = await _context.Database.BeginTransactionAsync();

            try
            {
                var document = await _context.Documents.FindAsync(id);
                if (document == null)
                    return NotFound("Document not found!");

                // Delete related records in DocumentCircuitHistory
                var historyRecords = await _context.DocumentCircuitHistory
                    .Where(dch => dch.DocumentId == id)
                    .ToListAsync();

                if (historyRecords.Any())
                    _context.DocumentCircuitHistory.RemoveRange(historyRecords);

                // Delete related records in DocumentStatus
                var statusRecords = await _context.DocumentStatus
                    .Where(ds => ds.DocumentId == id)
                    .ToListAsync();

                if (statusRecords.Any())
                    _context.DocumentStatus.RemoveRange(statusRecords);

                // Update the document type counter
                var type = await _context.DocumentTypes.FindAsync(document.TypeId);
                if (type == null)
                    return BadRequest("Missing DocumentType");
                if (type.DocumentCounter > 0)
                    type.DocumentCounter--;

                // Log the deletion
                var logEntry = new LogHistory
                {
                    UserId = userId,
                    User = user,
                    Timestamp = DateTime.UtcNow,
                    ActionType = 6,
                    Description = $"{user.Username} has deleted the document {document.DocumentKey}"
                };
                _context.LogHistories.Add(logEntry);

                // Delete the document
                _context.Documents.Remove(document);
                await _context.SaveChangesAsync();

                // Commit the transaction
                await transaction.CommitAsync();

                return Ok("Document deleted!");
            }
            catch (Exception ex)
            {
                // Roll back the transaction on error
                await transaction.RollbackAsync();
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpGet("Types")]
        public async Task<ActionResult> GetTypes()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID or Role claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");
            var types = await _context.DocumentTypes.ToListAsync();
            return Ok(types);
        }

        [HttpGet("Types/{id}")]
        public async Task<ActionResult<DocumentType>> GetDocumentType(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact an admin!");

            var documentType = await _context.DocumentTypes.FindAsync(id);

            if (documentType == null)
                return NotFound("Document type not found.");

            return Ok(documentType);
        }

        [HttpPost("valide-typeKey")]
        public async Task<IActionResult> ValideTypeKey([FromBody] DocumentTypeDto request)
        {
            if (await _context.DocumentTypes.AnyAsync(t => t.TypeKey == request.TypeKey))
                return Ok("False");
            return Ok("True");
        }

        [HttpPost("Types")]
        public async Task<ActionResult> CreateTypes([FromBody] DocumentTypeDto request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to do this action.");
            if (string.IsNullOrEmpty(request.TypeName))
                return BadRequest("Type Name is required!");
            var typeNameExists = await _context.DocumentTypes.AnyAsync(t => t.TypeName == request.TypeName);
            if (typeNameExists)
                return BadRequest("Type Name already exists!");
            var typeCounter = await _context.TypeCounter.FirstOrDefaultAsync();
            if (typeCounter == null)
            {
                typeCounter = new TypeCounter { Counter = 1 };
                _context.TypeCounter.Add(typeCounter);
            }
            string baseKey = (request.TypeName.Length >= 2) ? request.TypeName.Substring(0, 2).ToUpper() : request.TypeName.ToUpper();
            if (!string.IsNullOrEmpty(request.TypeKey))
                baseKey = request.TypeKey;
            bool exists = await _context.DocumentTypes.AnyAsync(t => t.TypeKey == baseKey);
            string finalTypeKey = exists ? $"{baseKey}{typeCounter.Counter++}" : baseKey;
            var type = new DocumentType
            {
                TypeKey = finalTypeKey,
                TypeName = request.TypeName,
                TypeAttr = request.TypeAttr,
                DocumentCounter = 0,
                DocCounter = 0
            };
            _context.DocumentTypes.Add(type);
            await _context.SaveChangesAsync();
            return Ok("Type successfully added!");
        }

        [HttpPost("valide-type")]
        public async Task<IActionResult> ValideType([FromBody] DocumentTypeDto request)
        {
            var typeName = request.TypeName.ToLower();
            var type = await _context.DocumentTypes.AnyAsync(t => t.TypeName.ToLower() == typeName);
            if (type)
                return Ok("True");
            return Ok("False");
        }

        [HttpPut("Types/{id}")]
        public async Task<IActionResult> UpdateType([FromBody] DocumentTypeDto request, int id)
        {
            var ThisType = await _context.DocumentTypes.FindAsync(id);
            if (ThisType == null)
                return NotFound("No type with this id!");
            if (!string.IsNullOrEmpty(request.TypeName))
            {
                var typeName = request.TypeName.ToLower();
                var type = await _context.DocumentTypes.FirstOrDefaultAsync(t => t.TypeName.ToLower() == typeName);
                if (type != null && type.Id != ThisType.Id)
                    return BadRequest("TypeName already exist");
                // if ()
                ThisType.TypeName = request.TypeName;
            }
            if (!string.IsNullOrEmpty(request.TypeAttr))
                ThisType.TypeAttr = request.TypeAttr;
            // _context.DocumentTypes.Add(ThisType);
            await _context.SaveChangesAsync();
            return Ok("Type edited successfully");
        }

        [HttpDelete("Types/{id}")]
        public async Task<IActionResult> DeleteType(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");
            var type = await _context.DocumentTypes.FindAsync(id);
            if (type == null)
                return NotFound("No type with this id!");
            if (type.DocumentCounter > 0)
                return BadRequest("This type can't be deleted. There are documents registered with!");
            _context.DocumentTypes.Remove(type);
            await _context.SaveChangesAsync();

            return Ok("Type deleted!");
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Mappings;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class LignesController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public LignesController(ApplicationDbContext context) { _context = context; }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<LigneDto>>> GetLignes()
        {
            var lignes = await _context.Lignes
                .Include(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(LigneMappings.ToLigneDto).ToListAsync();
            return Ok(lignes);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<LigneDto>> GetLigne(int id)
        {
            var ligneDto = await _context.Lignes
                .Include(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Where(l => l.Id == id).Select(LigneMappings.ToLigneDto).FirstOrDefaultAsync();
            if (ligneDto == null)
                return NotFound("Ligne not found.");
            return Ok(ligneDto);
        }

        [HttpGet("by-document/{documentId}")]
        public async Task<ActionResult<IEnumerable<LigneDto>>> GetLignesByDocumentId(int documentId)
        {
            var lignes = await _context.Lignes
                .Where(l => l.DocumentId == documentId)
                .Include(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(LigneMappings.ToLigneDto).ToListAsync();
            return Ok(lignes);
        }

        [HttpPost]
        public async Task<ActionResult<LigneDto>> CreateLigne([FromBody] Ligne ligne)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var document = await _context.Documents.FindAsync(ligne.DocumentId);
            if (document == null)
                return BadRequest("Invalid DocumentId. Document not found.");
            ligne.CreatedAt = DateTime.UtcNow;
            ligne.UpdatedAt = DateTime.UtcNow;
            ligne.LigneKey = $"{document.DocumentKey}L{document.LigneCouter++}";
            _context.Lignes.Add(ligne);
            await _context.SaveChangesAsync();
            var ligneDto = await _context.Lignes
                .Include(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Where(l => l.Id == ligne.Id).Select(LigneMappings.ToLigneDto).FirstOrDefaultAsync();
            return CreatedAtAction(nameof(GetLigne), new { id = ligne.Id }, ligneDto);
        }


        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateLigne(int id, [FromBody] Ligne updatedLigne)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var ligne = await _context.Lignes.FindAsync(id);
            if (ligne == null)
                return NotFound("Ligne not found.");
            if (!string.IsNullOrEmpty(updatedLigne.Title))
                ligne.Title = updatedLigne.Title;
            if (!string.IsNullOrEmpty(updatedLigne.Article))
                ligne.Article = updatedLigne.Article;
            if (updatedLigne.Prix >= 0)
                ligne.Prix = updatedLigne.Prix;
            ligne.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
            return Ok("Ligne updated!");
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteLigne(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var ligne = await _context.Lignes.FindAsync(id);
            if (ligne == null)
                return NotFound("Ligne not found.");
            _context.Lignes.Remove(ligne);
            await _context.SaveChangesAsync();
            return Ok("Ligne deleted!");
        }
    }
}
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using Google.Apis.Auth;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace DocManagementBackend.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class OAuthController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly IConfiguration _config;
        public OAuthController(ApplicationDbContext context, IConfiguration config){ _context = context; _config = config;}

        [HttpPost("google-login")]
        public async Task<IActionResult> GoogleLogin([FromBody] GoogleLoginRequest request) {
            try {
                var payload = await GoogleJsonWebSignature.ValidateAsync(request.IdToken);
                var user = await _context.Users.Include(u => u.Role)
                                  .FirstOrDefaultAsync(u => u.Email == payload.Email);
                if (user == null) {
                    user = new User {
                        Email = payload.Email,
                        Username = payload.Email.Split('@')[0],
                        FirstName = payload.GivenName, LastName = payload.FamilyName,
                        IsEmailConfirmed = true, IsActive = true, CreatedAt = DateTime.UtcNow,
                        PasswordHash = BCrypt.Net.BCrypt.HashPassword(Guid.NewGuid().ToString())};
                    var simpleUserRole = await _context.Roles.FirstOrDefaultAsync(r => r.RoleName == "SimpleUser");
                    if (simpleUserRole != null) {
                        user.RoleId = simpleUserRole.Id;
                        user.Role = simpleUserRole;}

                    _context.Users.Add(user);
                    await _context.SaveChangesAsync();
                }
                var accessToken = GenerateAccessToken(user);
                return Ok(new { accessToken });
            }
            catch (Exception ex) {
                return Unauthorized($"Invalid Google token: {ex.Message}");}
        }

        private string GenerateAccessToken(User user) {
            var secretKey = Environment.GetEnvironmentVariable("JWT_SECRET");;
            if (string.IsNullOrEmpty(secretKey))
                throw new InvalidOperationException("JWT configuration is missing.");

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey));
            var claims = new[] {new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
                new Claim(JwtRegisteredClaimNames.Email, user.Email),
                new Claim("Username", user.Username),
                new Claim("IsActive", user.IsActive.ToString()),
                new Claim(ClaimTypes.Role, user.Role?.RoleName ?? "SimpleUser")};

            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            var expMinutes = Environment.GetEnvironmentVariable("ExpiryMinutes");
            if (string.IsNullOrEmpty(expMinutes))
                throw new InvalidOperationException("ExpiryMinutes is missing.");

            var token = new JwtSecurityToken(issuer: Environment.GetEnvironmentVariable("ISSUER"),
                audience: Environment.GetEnvironmentVariable("AUDIENCE"), claims: claims,
                expires: DateTime.UtcNow.AddMinutes(int.Parse(expMinutes)),
                signingCredentials: creds);

            return new JwtSecurityTokenHandler().WriteToken(token);
        }
    }
}// using Microsoft.AspNetCore.Mvc;
// using System.Threading.Tasks;
// using DocManagementBackend.Services;
// using DocManagementBackend.Models;
// using DocManagementBackend.Data;
// using Microsoft.EntityFrameworkCore;

// namespace DocManagementBackend.Controllers
// {
//     [Route("api/[controller]")]
//     [ApiController]
//     public class PhoneVerificationController : ControllerBase
//     {
//         private readonly SmsVerificationService _verificationService;
//         private readonly ApplicationDbContext _context;

//         public PhoneVerificationController(SmsVerificationService verificationService, ApplicationDbContext context)
//         {
//             _verificationService = verificationService;
//             _context = context;
//         }

//         [HttpPost("send-code")]
//         public async Task<IActionResult> SendVerificationCode([FromBody] PhoneVerificationRequest request)
//         {
//             try
//             {
//                 if (string.IsNullOrEmpty(request.PhoneNumber))
//                 {
//                     return BadRequest(new { message = "Phone number is required" });
//                 }

//                 var sessionInfo = await _verificationService.SendVerificationCode(request.PhoneNumber);
//                 return Ok(new
//                 {
//                     sessionInfo,
//                     message = "Verification code generated. Check the server console output to get the code."
//                 });
//             }
//             catch (Exception ex)
//             {
//                 return BadRequest(new { message = $"Failed to send verification code: {ex.Message}" });
//             }
//         }

//         [HttpPost("verify")]
//         public async Task<IActionResult> VerifyPhoneNumber([FromBody] VerifyPhoneRequest request)
//         {
//             if (string.IsNullOrEmpty(request.PhoneNumber) || string.IsNullOrEmpty(request.Code))
//             {
//                 return BadRequest(new { message = "Phone number and verification code are required" });
//             }

//             var isVerified = await _verificationService.VerifyPhoneNumber(
//                 request.SessionInfo, request.Code, request.PhoneNumber);

//             if (isVerified)
//             {
//                 if (request.UserId > 0)
//                 {
//                     var user = await _context.Users.FindAsync(request.UserId);
//                     if (user != null)
//                     {
//                         user.PhoneNumber = request.PhoneNumber;
//                         user.IsPhoneVerified = true; // Make sure this field exists
//                         await _context.SaveChangesAsync();
//                     }
//                 }

//                 return Ok(new { message = "Phone number verified successfully" });
//             }

//             return BadRequest(new { message = "Invalid verification code" });
//         }
//     }
// }using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Mappings;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class SousLignesController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public SousLignesController(ApplicationDbContext context) { _context = context; }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<SousLigne>>> GetSousLignes()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var sousLigne = await _context.SousLignes
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).ToListAsync();
            return Ok(sousLigne);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<SousLigne>> GetSousLigne(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var sousLigne = await _context.SousLignes
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).FirstOrDefaultAsync(s => s.Id == id);

            if (sousLigne == null)
                return NotFound("SousLigne not found.");

            return Ok(sousLigne);
        }

        [HttpGet("by_ligne/{id}")]
        public async Task<ActionResult<SousLigne>> GetSousLigneByLigneId(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var sousLigne = await _context.SousLignes
                .Where(s => s.LigneId == id)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).ToListAsync();
            if (sousLigne == null)
                return NotFound("No SousLigne found with that ligne.");
            return Ok(sousLigne);
        }

        [HttpGet("by_document/{id}")]
        public async Task<ActionResult<SousLigne>> GetSousLigneByDocId(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var sousLigne = await _context.SousLignes
                .Where(s => s.Ligne!.DocumentId == id)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).ToListAsync();
            if (sousLigne == null)
                return NotFound("No SousLigne found linked to document.");
            return Ok(sousLigne);
        }

        [HttpPost]
        public async Task<ActionResult<SousLigne>> CreateSousLigne([FromBody] SousLigne sousLigne)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var ligne = await _context.Lignes.FindAsync(sousLigne.LigneId);
            if (ligne == null)
                return BadRequest("Invalid LigneId. Ligne not found.");
            sousLigne.CreatedAt = DateTime.UtcNow;
            sousLigne.UpdatedAt = DateTime.UtcNow;
            sousLigne.SousLigneKey = $"{ligne.LigneKey}SL{ligne.SousLigneCounter++}";
            _context.SousLignes.Add(sousLigne);
            await _context.SaveChangesAsync();
            var sousLigneDto = await _context.SousLignes
                .Where(s => s.Id == sousLigne.Id)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).ToListAsync();
            return CreatedAtAction(nameof(GetSousLigne), new { id = sousLigne.Id }, sousLigneDto);
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateSousLigne(int id, [FromBody] SousLigne updatedSousLigne)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var sousLigne = await _context.SousLignes.FindAsync(id);
            if (sousLigne == null)
                return NotFound("SousLigne not found.");
            if (!string.IsNullOrEmpty(updatedSousLigne.Title))
                sousLigne.Title = updatedSousLigne.Title;
            if (!string.IsNullOrEmpty(updatedSousLigne.Attribute))
                sousLigne.Attribute = updatedSousLigne.Attribute;
            sousLigne.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
            return Ok("SousLigne updated!");
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteSousLigne(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var sousLigne = await _context.SousLignes.FindAsync(id);
            if (sousLigne == null)
                return NotFound("SousLigne not found.");
            _context.SousLignes.Remove(sousLigne);
            await _context.SaveChangesAsync();
            return Ok("SousLigne deleted!");
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class StatusController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public StatusController(ApplicationDbContext context)
        {
            _context = context;
        }

        [HttpGet("step/{stepId}")]
        public async Task<ActionResult<IEnumerable<StatusDto>>> GetStatusesForStep(int stepId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var statuses = await _context.Status
                .Where(s => s.StepId == stepId)
                .OrderBy(s => s.Id)
                .Select(s => new StatusDto
                {
                    StatusId = s.Id,
                    StatusKey = s.StatusKey,
                    Title = s.Title,
                    IsRequired = s.IsRequired,
                    IsComplete = s.IsComplete,
                    StepId = s.StepId
                })
                .ToListAsync();

            return Ok(statuses);
        }

        [HttpPost("step/{stepId}")]
        public async Task<ActionResult<StatusDto>> AddStatusToStep(int stepId, [FromBody] CreateStatusDto createStatusDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to add statuses.");

            var step = await _context.Steps.FindAsync(stepId);
            if (step == null)
                return NotFound("Step not found.");

            var status = new Status
            {
                StepId = stepId,
                Title = createStatusDto.Title,
                IsRequired = createStatusDto.IsRequired,
                IsComplete = false,
                StatusKey = $"ST-{Guid.NewGuid().ToString().Substring(0, 3)}"
            };

            _context.Status.Add(status);
            await _context.SaveChangesAsync();

            return CreatedAtAction(nameof(GetStatusesForStep), new { stepId = stepId }, new StatusDto
            {
                StatusId = status.Id,
                StatusKey = status.StatusKey,
                Title = status.Title,
                IsRequired = status.IsRequired,
                IsComplete = status.IsComplete,
                StepId = status.StepId
            });
        }

        [HttpPut("{statusId}")]
        public async Task<IActionResult> UpdateStatus(int statusId, [FromBody] CreateStatusDto updateStatusDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to update statuses.");

            var status = await _context.Status.FindAsync(statusId);
            if (status == null)
                return NotFound("Status not found.");

            if (!string.IsNullOrEmpty(updateStatusDto.Title))
                status.Title = updateStatusDto.Title;
            status.IsRequired = updateStatusDto.IsRequired;
            // status.IsComplete = updateStatusDto.IsComplete;

            await _context.SaveChangesAsync();
            return Ok("Status updated successfully.");
        }

        [HttpDelete("{statusId}")]
        public async Task<IActionResult> DeleteStatus(int statusId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to delete statuses.");

            var status = await _context.Status.FindAsync(statusId);
            if (status == null)
                return NotFound("Status not found.");

            // Check if documents are already using this status
            var inUse = await _context.DocumentStatus.AnyAsync(ds => ds.StatusId == statusId);
            if (inUse)
                return BadRequest("Cannot delete status that is in use by documents.");

            _context.Status.Remove(status);
            await _context.SaveChangesAsync();

            return Ok("Status deleted successfully.");
        }
    }
}using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class SubTypeController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public SubTypeController(ApplicationDbContext context)
        {
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<SubTypeDto>>> GetSubTypes()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var subTypes = await _context.SubTypes
                .Include(st => st.DocumentType)
                .Select(st => new SubTypeDto
                {
                    Id = st.Id,
                    SubTypeKey = st.SubTypeKey,
                    Name = st.Name,
                    Description = st.Description,
                    StartDate = st.StartDate,
                    EndDate = st.EndDate,
                    DocumentTypeId = st.DocumentTypeId,
                    IsActive = st.IsActive,
                    DocumentType = new DocumentTypeDto
                    {
                        TypeKey = st.DocumentType!.TypeKey,
                        TypeName = st.DocumentType.TypeName,
                        TypeAttr = st.DocumentType.TypeAttr
                    }
                })
                .ToListAsync();

            return Ok(subTypes);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<SubTypeDto>> GetSubType(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var subType = await _context.SubTypes
                .Include(st => st.DocumentType)
                .Where(st => st.Id == id)
                .Select(st => new SubTypeDto
                {
                    Id = st.Id,
                    SubTypeKey = st.SubTypeKey,
                    Name = st.Name,
                    Description = st.Description,
                    StartDate = st.StartDate,
                    EndDate = st.EndDate,
                    DocumentTypeId = st.DocumentTypeId,
                    IsActive = st.IsActive,
                    DocumentType = new DocumentTypeDto
                    {
                        TypeKey = st.DocumentType!.TypeKey,
                        TypeName = st.DocumentType.TypeName,
                        TypeAttr = st.DocumentType.TypeAttr
                    }
                })
                .FirstOrDefaultAsync();

            if (subType == null)
                return NotFound("SubType not found.");

            return Ok(subType);
        }

        [HttpGet("by-document-type/{docTypeId}")]
        public async Task<ActionResult<IEnumerable<SubTypeDto>>> GetSubTypesByDocType(int docTypeId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var subTypes = await _context.SubTypes
                .Include(st => st.DocumentType)
                .Where(st => st.DocumentTypeId == docTypeId)
                .Select(st => new SubTypeDto
                {
                    Id = st.Id,
                    SubTypeKey = st.SubTypeKey,
                    Name = st.Name,
                    Description = st.Description,
                    StartDate = st.StartDate,
                    EndDate = st.EndDate,
                    DocumentTypeId = st.DocumentTypeId,
                    IsActive = st.IsActive,
                    DocumentType = new DocumentTypeDto
                    {
                        TypeKey = st.DocumentType!.TypeKey,
                        TypeName = st.DocumentType.TypeName,
                        TypeAttr = st.DocumentType.TypeAttr
                    }
                })
                .ToListAsync();

            return Ok(subTypes);
        }

        [HttpGet("for-date/{docTypeId}/{date}")]
        public async Task<ActionResult<IEnumerable<SubTypeDto>>> GetSubTypesForDate(int docTypeId, DateTime date)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var subTypes = await _context.SubTypes
                .Include(st => st.DocumentType)
                .Where(st => st.DocumentTypeId == docTypeId &&
                             st.IsActive &&
                             st.StartDate <= date &&
                             st.EndDate >= date)
                .Select(st => new SubTypeDto
                {
                    Id = st.Id,
                    SubTypeKey = st.SubTypeKey,
                    Name = st.Name,
                    Description = st.Description,
                    StartDate = st.StartDate,
                    EndDate = st.EndDate,
                    DocumentTypeId = st.DocumentTypeId,
                    IsActive = st.IsActive,
                    DocumentType = new DocumentTypeDto
                    {
                        TypeKey = st.DocumentType!.TypeKey,
                        TypeName = st.DocumentType.TypeName,
                        TypeAttr = st.DocumentType.TypeAttr
                    }
                })
                .ToListAsync();

            return Ok(subTypes);
        }

        [HttpPost]
        public async Task<ActionResult<SubTypeDto>> CreateSubType([FromBody] CreateSubTypeDto createSubTypeDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (thisUser.Role!.RoleName != "Admin" && thisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to create subtypes.");

            // Check if DocumentType exists
            var documentType = await _context.DocumentTypes.FindAsync(createSubTypeDto.DocumentTypeId);
            if (documentType == null)
                return BadRequest("Invalid Document Type ID.");

            // Validate date range
            if (createSubTypeDto.StartDate >= createSubTypeDto.EndDate)
                return BadRequest("Start date must be before end date.");

            // Check for overlapping periods with the same name for this document type
            var overlappingSubType = await _context.SubTypes
                .Where(st => st.DocumentTypeId == createSubTypeDto.DocumentTypeId &&
                             st.Name.ToLower() == createSubTypeDto.Name.ToLower() &&
                             ((st.StartDate <= createSubTypeDto.StartDate && st.EndDate >= createSubTypeDto.StartDate) ||
                              (st.StartDate <= createSubTypeDto.EndDate && st.EndDate >= createSubTypeDto.EndDate) ||
                              (st.StartDate >= createSubTypeDto.StartDate && st.EndDate <= createSubTypeDto.EndDate)))
                .FirstOrDefaultAsync();

            if (overlappingSubType != null)
                return BadRequest($"A subtype with name '{createSubTypeDto.Name}' already exists for this document type within the specified date range.");

            // Generate the SubTypeKey
            // Format example: {TypeKey}{FirstLettersOfName}{YearEnd} = "FAAB25"
            string namePrefix = string.Join("", createSubTypeDto.Name.Take(2)).ToUpper();
            string yearSuffix = createSubTypeDto.EndDate.ToString("yy"); // 2-digit year
            string subTypeKey = $"{documentType.TypeKey}{namePrefix}{yearSuffix}";

            // Check if this key already exists, if so, make it unique
            bool keyExists = await _context.SubTypes.AnyAsync(st => st.SubTypeKey == subTypeKey);
            if (keyExists)
            {
                // Add a numeric suffix until we find a unique key
                int counter = 1;
                string newKey;
                do
                {
                    newKey = $"{subTypeKey}{counter}";
                    keyExists = await _context.SubTypes.AnyAsync(st => st.SubTypeKey == newKey);
                    counter++;
                } while (keyExists && counter < 100);

                subTypeKey = newKey;
            }

            var subType = new SubType
            {
                Name = createSubTypeDto.Name,
                Description = createSubTypeDto.Description,
                StartDate = createSubTypeDto.StartDate,
                EndDate = createSubTypeDto.EndDate,
                DocumentTypeId = createSubTypeDto.DocumentTypeId,
                IsActive = createSubTypeDto.IsActive,
                SubTypeKey = subTypeKey
            };

            _context.SubTypes.Add(subType);
            await _context.SaveChangesAsync();

            var subTypeDto = new SubTypeDto
            {
                Id = subType.Id,
                SubTypeKey = subType.SubTypeKey,
                Name = subType.Name,
                Description = subType.Description,
                StartDate = subType.StartDate,
                EndDate = subType.EndDate,
                DocumentTypeId = subType.DocumentTypeId,
                IsActive = subType.IsActive,
                DocumentType = new DocumentTypeDto
                {
                    TypeKey = documentType.TypeKey,
                    TypeName = documentType.TypeName,
                    TypeAttr = documentType.TypeAttr
                }
            };

            return CreatedAtAction(nameof(GetSubType), new { id = subType.Id }, subTypeDto);
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateSubType(int id, [FromBody] UpdateSubTypeDto updateSubTypeDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (thisUser.Role!.RoleName != "Admin" && thisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to update subtypes.");

            var subType = await _context.SubTypes.FindAsync(id);
            if (subType == null)
                return NotFound("SubType not found.");

            // Check if we need to update dates and validate
            DateTime startDate = updateSubTypeDto.StartDate ?? subType.StartDate;
            DateTime endDate = updateSubTypeDto.EndDate ?? subType.EndDate;

            if (startDate >= endDate)
                return BadRequest("Start date must be before end date.");

            // Check for name update and potential overlaps
            string name = updateSubTypeDto.Name ?? subType.Name;

            if (updateSubTypeDto.Name != null || updateSubTypeDto.StartDate.HasValue || updateSubTypeDto.EndDate.HasValue)
            {
                // Check for overlapping periods with the same name for this document type
                var overlappingSubType = await _context.SubTypes
                    .Where(st => st.Id != id &&
                                 st.DocumentTypeId == subType.DocumentTypeId &&
                                 st.Name.ToLower() == name.ToLower() &&
                                 ((st.StartDate <= startDate && st.EndDate >= startDate) ||
                                  (st.StartDate <= endDate && st.EndDate >= endDate) ||
                                  (st.StartDate >= startDate && st.EndDate <= endDate)))
                    .FirstOrDefaultAsync();

                if (overlappingSubType != null)
                    return BadRequest($"A subtype with name '{name}' already exists for this document type within the specified date range.");
            }

            // Update the SubType
            if (updateSubTypeDto.Name != null)
                subType.Name = updateSubTypeDto.Name;

            if (updateSubTypeDto.Description != null)
                subType.Description = updateSubTypeDto.Description;

            if (updateSubTypeDto.StartDate.HasValue)
                subType.StartDate = updateSubTypeDto.StartDate.Value;

            if (updateSubTypeDto.EndDate.HasValue)
                subType.EndDate = updateSubTypeDto.EndDate.Value;

            if (updateSubTypeDto.IsActive.HasValue)
                subType.IsActive = updateSubTypeDto.IsActive.Value;

            // If the name or dates changed, update the SubTypeKey
            if (updateSubTypeDto.Name != null || updateSubTypeDto.EndDate.HasValue)
            {
                var documentType = await _context.DocumentTypes.FindAsync(subType.DocumentTypeId);
                if (documentType != null)
                {
                    string namePrefix = string.Join("", subType.Name.Take(2)).ToUpper();
                    string yearSuffix = subType.EndDate.ToString("yy"); // 2-digit year
                    string newSubTypeKey = $"{documentType.TypeKey}{namePrefix}{yearSuffix}";

                    // Check if this key already exists, if so, make it unique
                    bool keyExists = await _context.SubTypes.AnyAsync(st => st.SubTypeKey == newSubTypeKey && st.Id != id);
                    if (keyExists)
                    {
                        // Add a numeric suffix until we find a unique key
                        int counter = 1;
                        string tempKey;
                        do
                        {
                            tempKey = $"{newSubTypeKey}{counter}";
                            keyExists = await _context.SubTypes.AnyAsync(st => st.SubTypeKey == tempKey && st.Id != id);
                            counter++;
                        } while (keyExists && counter < 100);

                        newSubTypeKey = tempKey;
                    }

                    subType.SubTypeKey = newSubTypeKey;
                }
                else
                {
                    return BadRequest("Document type not found.");
                }
            }

            try
            {
                await _context.SaveChangesAsync();
                return Ok("SubType updated successfully");
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await _context.SubTypes.AnyAsync(st => st.Id == id))
                    return NotFound("SubType not found");
                throw;
            }
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteSubType(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (thisUser.Role!.RoleName != "Admin" && thisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to delete subtypes.");

            var subType = await _context.SubTypes.FindAsync(id);
            if (subType == null)
                return NotFound("SubType not found.");

            // Check if this subtype is used by any documents
            bool isUsed = await _context.Documents.AnyAsync(d => d.SubTypeId == id);
            if (isUsed)
                return BadRequest("Cannot delete this subtype because it is used by one or more documents.");

            _context.SubTypes.Remove(subType);
            await _context.SaveChangesAsync();

            return Ok("SubType deleted successfully.");
        }
    }
}using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Services;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class WorkflowController : ControllerBase
    {
        private readonly DocumentWorkflowService _workflowService;
        private readonly ApplicationDbContext _context;

        public WorkflowController(DocumentWorkflowService workflowService, ApplicationDbContext context)
        {
            _workflowService = workflowService;
            _context = context;
        }

        [HttpPost("assign-circuit")]
        public async Task<IActionResult> AssignDocumentToCircuit([FromBody] AssignCircuitDto assignCircuitDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to assign documents to circuits.");

            try
            {
                var success = await _workflowService.AssignDocumentToCircuitAsync(
                    assignCircuitDto.DocumentId, assignCircuitDto.CircuitId, userId);

                if (success)
                    return Ok("Document assigned to circuit successfully.");
                else
                    return BadRequest("Failed to assign document to circuit.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("perform-action")]
        public async Task<IActionResult> PerformAction([FromBody] PerformActionDto actionDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to do this action.");

            try
            {
                var success = await _workflowService.ProcessActionAsync(
                    actionDto.DocumentId, actionDto.ActionId, userId, actionDto.Comments, actionDto.IsApproved);

                if (success)
                    return Ok("Action performed successfully.");
                else
                    return BadRequest("Failed to perform action.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("change-step")]
        public async Task<IActionResult> MoveToNextStep([FromBody] MoveNextDto moveNextDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to perform this action.");

            try
            {
                var success = await _workflowService.MoveToNextStepAsync(
                    moveNextDto.DocumentId,
                    moveNextDto.CurrentStepId,
                    moveNextDto.NextStepId,
                    userId,
                    moveNextDto.Comments);

                if (success)
                    return Ok("Document moved to next step successfully.");
                else
                    return BadRequest("Failed to move document to next step.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("move-next")]
        public async Task<IActionResult> MoveToNextStep([FromBody] MoveToDocumentDto moveDocumentDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to perform this action.");

            try
            {
                // Get the document and its current step
                var document = await _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .FirstOrDefaultAsync(d => d.Id == moveDocumentDto.DocumentId);

                if (document == null)
                    return NotFound("Document not found.");

                if (document.CurrentStepId == null)
                    return BadRequest("Document is not currently in any workflow step.");

                if (document.CircuitId == null)
                    return BadRequest("Document is not assigned to any circuit.");

                // Find the next step based on order index
                var currentStep = await _context.Steps.FindAsync(document.CurrentStepId);
                if (currentStep == null)
                    return BadRequest("Current step not found.");

                // Get all steps in the circuit ordered by OrderIndex
                var circuitSteps = await _context.Steps
                    .Where(s => s.CircuitId == document.CircuitId)
                    .OrderBy(s => s.OrderIndex)
                    .ToListAsync();

                // Find the next step
                Step? nextStep = null;
                for (int i = 0; i < circuitSteps.Count; i++)
                {
                    if (circuitSteps[i].Id == currentStep.Id && i < circuitSteps.Count - 1)
                    {
                        nextStep = circuitSteps[i + 1];
                        break;
                    }
                }

                if (nextStep == null)
                {
                    // Check if current step is final
                    if (currentStep.IsFinalStep)
                        return BadRequest("Current step is the final step in the workflow.");
                    else
                        return BadRequest("No next step found in the workflow.");
                }

                // Pass to the service method
                var success = await _workflowService.MoveToNextStepAsync(
                    moveDocumentDto.DocumentId,
                    currentStep.Id,
                    nextStep.Id,
                    userId,
                    moveDocumentDto.Comments);

                if (success)
                    return Ok("Document moved to next step successfully.");
                else
                    return BadRequest("Failed to move document to next step.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("return-to-previous")]
        public async Task<IActionResult> ReturnToPreviousStep([FromBody] ReturnToPreviousDto returnDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to do action.");

            try
            {
                var success = await _workflowService.ReturnToPreviousStepAsync(
                    returnDto.DocumentId, userId, returnDto.Comments);

                if (success)
                    return Ok("Document returned to previous step successfully.");
                else
                    return BadRequest("Failed to return document to previous step.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("complete-status")]
        public async Task<IActionResult> CompleteDocumentStatus([FromBody] CompleteStatusDto completeStatusDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            try
            {
                var success = await _workflowService.CompleteDocumentStatusAsync(
                    completeStatusDto.DocumentId,
                    completeStatusDto.StatusId,
                    userId,
                    completeStatusDto.IsComplete,
                    completeStatusDto.Comments);

                if (success)
                    return Ok("Document status updated successfully.");
                else
                    return BadRequest("Failed to update document status.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpGet("document/{documentId}/step-statuses")]
        public async Task<ActionResult<IEnumerable<DocumentStatusDto>>> GetDocumentStepStatuses(int documentId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role)
                .FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            // Get the document and check if it has a current step
            var document = await _context.Documents
                .Include(d => d.CurrentStep)
                .FirstOrDefaultAsync(d => d.Id == documentId);

            if (document == null)
                return NotFound("Document not found.");

            if (document.CurrentStepId == null)
                return NotFound("Document is not currently in any workflow step.");

            // Get statuses for the current step with completion info for this document
            var statuses = await _context.Status
                .Where(s => s.StepId == document.CurrentStepId)
                .OrderBy(s => s.Id)
                .Select(s => new
                {
                    Status = s,
                    DocumentStatus = _context.DocumentStatus
                        .FirstOrDefault(ds => ds.DocumentId == documentId && ds.StatusId == s.Id)
                })
                .ToListAsync();

            var statusDtos = statuses.Select(item => new DocumentStatusDto
            {
                StatusId = item.Status.Id,
                Title = item.Status.Title,
                IsRequired = item.Status.IsRequired,
                IsComplete = item.DocumentStatus?.IsComplete ?? false,
                CompletedBy = item.DocumentStatus != null && item.DocumentStatus.CompletedByUserId.HasValue
                    ? _context.Users
                        .Where(u => u.Id == item.DocumentStatus.CompletedByUserId.Value)
                        .Select(u => u.Username)
                        .FirstOrDefault()
                    : null,
                CompletedAt = item.DocumentStatus?.CompletedAt
            }).ToList();

            return Ok(statusDtos);
        }

        [HttpGet("document/{documentId}/history")]
        public async Task<ActionResult<IEnumerable<DocumentHistoryDto>>> GetDocumentHistory(int documentId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            try
            {
                var history = await _context.DocumentCircuitHistory
                    .Where(h => h.DocumentId == documentId)
                    .Include(h => h.Step)
                    .Include(h => h.ProcessedBy)
                    .Include(h => h.Action)
                    .Include(h => h.Status)
                    .OrderByDescending(h => h.ProcessedAt)
                    .ToListAsync();

                var historyDtos = history.Select(h => new DocumentHistoryDto
                {
                    Id = h.Id,
                    StepTitle = h.Step?.Title ?? "N/A",
                    ActionTitle = h.Action?.Title ?? "N/A",
                    StatusTitle = h.Status?.Title ?? "N/A",
                    ProcessedBy = h.ProcessedBy?.Username ?? "System",
                    ProcessedAt = h.ProcessedAt,
                    Comments = h.Comments,
                    IsApproved = h.IsApproved
                }).ToList();

                return Ok(historyDtos);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpGet("document/{documentId}/current-status")]
        public async Task<ActionResult<DocumentWorkflowStatusDto>> GetDocumentCurrentStatus(int documentId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            try
            {
                var document = await _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .FirstOrDefaultAsync(d => d.Id == documentId);

                if (document == null)
                    return NotFound("Document not found.");

                // Get current step's statuses with completion info
                var statusesQuery = from s in _context.Status
                                    where s.StepId == document.CurrentStepId
                                    join ds in _context.DocumentStatus
                                      on new { StatusId = s.Id, DocumentId = document.Id }
                                      equals new { StatusId = ds.StatusId, DocumentId = ds.DocumentId } into dsGroup
                                    from ds in dsGroup.DefaultIfEmpty()
                                    select new DocumentStatusDto
                                    {
                                        StatusId = s.Id,
                                        Title = s.Title,
                                        IsRequired = s.IsRequired,
                                        IsComplete = ds != null && ds.IsComplete,
                                        CompletedBy = ds != null && ds.CompletedByUserId.HasValue
                                            ? _context.Users
                                                .Where(u => u.Id == ds.CompletedByUserId.Value)
                                                .Select(u => u.Username)
                                                .FirstOrDefault()
                                            : null,
                                        CompletedAt = ds != null ? ds.CompletedAt : null
                                    };

                var statuses = await statusesQuery.ToListAsync();

                // Get actions available for current step
                var actions = await _context.StepActions
                    .Where(sa => sa.StepId == document.CurrentStepId)
                    .Select(sa => new ActionDto
                    {
                        ActionId = sa.ActionId,
                        Title = sa.Action!.Title,
                        Description = sa.Action.Description!
                    })
                    .ToListAsync();

                // Check if all required statuses are complete
                var canAdvance = statuses
                    .Where(s => s.IsRequired)
                    .All(s => s.IsComplete);

                // Check if backtracking is allowed
                var currentStep = document.CurrentStep;
                var canReturn = document.Circuit!.AllowBacktrack &&
                                currentStep != null &&
                                currentStep.PrevStepId.HasValue;

                var statusDto = new DocumentWorkflowStatusDto
                {
                    DocumentId = document.Id,
                    DocumentTitle = document.Title,
                    CircuitId = document.Circuit?.Id,
                    CircuitTitle = document.Circuit!.Title,
                    CurrentStepId = document.CurrentStepId,
                    CurrentStepTitle = document.CurrentStep!.Title,
                    Status = document.Status,
                    StatusText = GetStatusText(document.Status),
                    IsCircuitCompleted = document.IsCircuitCompleted,
                    Statuses = statuses,
                    AvailableActions = actions,
                    CanAdvanceToNextStep = canAdvance,
                    CanReturnToPreviousStep = canReturn
                };

                return Ok(statusDto);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpGet("pending-documents")]
        public async Task<ActionResult<IEnumerable<PendingDocumentDto>>> GetPendingDocuments()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            try
            {
                // Get documents that are:
                // 1. Assigned to a circuit
                // 2. Not completed
                // 3. Current step is assigned to user's role (if role assignment is enabled)
                var pendingQuery = _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .Include(d => d.CreatedBy)
                    .Where(d =>
                        d.CircuitId.HasValue &&
                        !d.IsCircuitCompleted &&
                        d.Status == 1 && // In Progress
                        d.CurrentStepId.HasValue);

                // Add role-based filtering if step has role assignment
                if (user.RoleId > 0) // Or another appropriate condition
                {
                    // For the first error - ensure CurrentStep is not null before accessing its properties
                    pendingQuery = pendingQuery.Where(d =>
                        d.CurrentStep != null &&
                        (!d.CurrentStep.ResponsibleRoleId.HasValue ||
                         d.CurrentStep.ResponsibleRoleId == user.RoleId));
                }

                var pendingDocuments = await pendingQuery.ToListAsync();

                var pendingDtos = pendingDocuments.Select(d => new PendingDocumentDto
                {
                    DocumentId = d.Id,
                    DocumentKey = d.DocumentKey,
                    Title = d.Title,
                    CreatedBy = d.CreatedBy?.Username ?? "Unknown",
                    CreatedAt = d.CreatedAt,
                    CircuitId = d.CircuitId!.Value,
                    CircuitTitle = d.Circuit?.Title ?? "Unknown",
                    CurrentStepId = d.CurrentStepId!.Value,
                    CurrentStepTitle = d.CurrentStep?.Title ?? "Unknown",
                    DaysInCurrentStep = (int)(DateTime.UtcNow - d.UpdatedAt).TotalDays
                }).ToList();

                return Ok(pendingDtos);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        private string GetStatusText(int status)
        {
            return status switch
            {
                0 => "Draft",
                1 => "In Progress",
                2 => "Completed",
                3 => "Rejected",
                _ => "Unknown"
            };
        }
    }
}